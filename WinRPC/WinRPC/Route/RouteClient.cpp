#include "RouteClient.h"

RouteClient::RouteClient(std::string routeManagerName, std::string clientName, unsigned channelMemSize, unsigned sendDatasMax, unsigned receiveDatasMax)
{
	m_routeManagerName = routeManagerName;
	m_clientName = clientName;
	m_channelMemSize = channelMemSize;
	m_sendDatasMax = sendDatasMax;
	m_receiveDatasMax = receiveDatasMax;
}

RouteClient::~RouteClient()
{

}

bool RouteClient::InitRouteClient()
{
	bool result = false;
	//Server相关的初始化
	std::string routeServerNoticeEventName = "ROUTE_SERVER_NOTICE_" + m_routeManagerName + "_WINRPC";
	m_hServerNoticeEvent = CreateEventA(NULL, FALSE, FALSE, routeServerNoticeEventName.c_str());
	std::string routeServerMutexName = "ROUTE_SERVER_MUTEX_" + m_routeManagerName + "_WINRPC";
	m_hServerMutex = CreateMutexA(NULL, FALSE, routeServerMutexName.c_str());
	std::string routeServerMemName = "Global\\ROUTE_SERVER_SHARE_" + m_routeManagerName + "_WINRPC";
	m_serverTableMem = new ShareMemory(routeServerMemName);

	if (m_serverTableMem != NULL)
	{
		m_serverMemAddr = m_serverTableMem->OpenShareMem(NULL, 4096);
		if (m_serverMemAddr != NULL)
		{
			//获取共享内存中的服务器列表
			std::string serverData;	//共享内存中存储的服务器信息
			serverData.resize(4096);
			if (WaitForSingleObject(m_hServerMutex, INFINITE) == WAIT_OBJECT_0)
			{
				m_serverTableMem->ReadShareMem(m_serverMemAddr, (void*)serverData.c_str(), 4096);
				ReleaseMutex(m_hServerMutex);//读取完共享内存以后,释放锁

				std::vector<ServerNode> serverNodes;
				ReadShareMemServerInfo(serverData, serverNodes);
				for (auto iter = serverNodes.begin(); iter != serverNodes.end(); iter++)
				{
					ServerNode serverNode = *iter;
					std::string serverName = serverNode.serverName;
					AddServer(serverName);
				}

				result = true;
			}
		}
	}
	return result;
}

bool RouteClient::AddServer(std::string serverName)
{
	bool result = false;
	const std::string channelName = serverName + "_" + m_clientName;
	//这里建立通道使用了(服务器名称+"_"+客户端名称),为了能够再添加了新的服务器以后,让客户端能够区分
	MemoryChannel* pChannel = new MemoryChannel(channelName, false , m_channelMemSize, m_sendDatasMax, m_receiveDatasMax);
	;
	if (pChannel != NULL)
	{
		if (pChannel->InitChannel() == NOT_ERROR)
		{
			m_serverChannelsMutex.lock();
			m_serverChannels[serverName] = pChannel;//添加客户端通道
			m_serverChannelsMutex.unlock();
			result = true;
		}
	}
	return result;
}

bool RouteClient::IsServerExist(std::string serverName)
{
	bool result = false;
	const std::string channelName = serverName + "_" + m_clientName;
	m_serverChannelsMutex.lock();
	if (m_serverChannels.find(channelName) != m_serverChannels.end())
	{
		result = true;
	}
	m_serverChannelsMutex.unlock();
	return result;
}

void RouteClient::BroadcastData(std::string data)
{
	m_serverChannelsMutex.lock();
	// 向所有的服务器发送一份数据(向服务器广播数据)
	for (auto iter = m_serverChannels.begin(); iter != m_serverChannels.end(); iter++)
	{
		MemoryChannel* pChannel = iter->second;
		pChannel->StoreSendData(data);
	}
	m_serverChannelsMutex.unlock();
}

void RouteClient::SendData(std::string serverName, std::string data)
{
	m_serverChannelsMutex.lock();
	//向指定的服务器发送数据(定向发送)
	if (m_serverChannels.find(serverName) != m_serverChannels.end())
	{
		MemoryChannel* pChannel = m_serverChannels[serverName];
		if (pChannel != NULL)
		{
			pChannel->StoreSendData(data);
		}
	}
	m_serverChannelsMutex.unlock();
}

bool RouteClient::GetReceivedDatas(std::vector<MsgNode>& datas)
{
	bool result = false;
	return result;
}

unsigned __stdcall RouteClient::ServerInfoMonitorThread(LPVOID args)
{
	RouteClient* p = (RouteClient*)args;
	while (true)
	{
		if (WaitForSingleObject(p->m_hServerNoticeEvent, 5000) == WAIT_OBJECT_0)
		{
			std::map<std::string, ServerNode> serverNodes;
			if (WaitForSingleObject(p->m_hServerMutex, INFINITE) == WAIT_OBJECT_0)
			{
				std::string serverData;
				serverData.resize(4096);
				p->m_serverTableMem->ReadShareMem(p->m_serverMemAddr, (void*)serverData.c_str(), 4096);
				ReleaseMutex(p->m_hServerMutex);//及时释放锁

				std::vector<ServerNode> serverNodes;
				ReadShareMemServerInfo(serverData, serverNodes);
				for (auto iter = serverNodes.begin(); iter != serverNodes.end(); iter++)
				{
					ServerNode serverNode = *iter;
					std::string serverName = serverNode.serverName;
					if (p->IsServerExist(serverName) == false) //判断,如果服务器资源已经创建过了,则不再进行资源创建
					{
						p->AddServer(serverName);
					}
				}
			}
		}
	}
	return 0;
}